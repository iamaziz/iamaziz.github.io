<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: machine | Blogy]]></title>
  <link href="http://iamaziz.github.io/blog/categories/machine/atom.xml" rel="self"/>
  <link href="http://iamaziz.github.io/"/>
  <updated>2015-06-12T04:26:08-04:00</updated>
  <id>http://iamaziz.github.io/</id>
  <author>
    <name><![CDATA[Aziz Alto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simple perceptron implementation in Python]]></title>
    <link href="http://iamaziz.github.io/blog/2015/05/24/simple-perceptron-implementation-in-python/"/>
    <updated>2015-05-24T22:10:47-04:00</updated>
    <id>http://iamaziz.github.io/blog/2015/05/24/simple-perceptron-implementation-in-python</id>
    <content type="html"><![CDATA[<h1 id="algorithm-4-fixed-increment-single-sample-perceptron">Algorithm 4 (Fixed-increment single-sample Perceptron)</h1>
<p>reference: Pattern Classification (Ch.5), Duda el at</p>

<p>Algorithm in <strong>pseudocode</strong>:</p>

<p><code>python
begin initialize a,k = 0
    do k = (k+1) mod n
        if yk is misclassified by a then a ← a − yk
    until all patterns properly classified
return a
end
</code></p>

<h3 id="steps-to-demo">Steps to demo:</h3>
<ul>
  <li>Get data. Training sample (negative/positive) and initial weight a0.</li>
  <li>Plot Neg/Pos data points.</li>
  <li>Augment training vectors.</li>
  <li>Apply fissp algorithm for classifying the pattern (and updating the weight error classification).
    <ul>
      <li>Show steps for the intermdiate solutions.</li>
    </ul>
  </li>
  <li>Get and solve the discriminant function: $g(x) = w^T x + w_0$
that is: <script type="math/tex">g(x) = \matrix{[a_1\; a_2]}.\begin{bmatrix}{x_1 \\ x_2}\end{bmatrix}.a_0 </script>
    <ul>
      <li>Using the adujsted weight $\alpha = [a_0, a_1, a_2]$.</li>
    </ul>
  </li>
  <li>Plot the decision boundary within some interval.</li>
  <li>Plot all intermediate updated weights.</li>
</ul>

<p>Repeat with other training samples and different weights (with no XOR data points).</p>

<pre><code>%matplotlib inline


import numpy as np
import matplotlib.pyplot as plt


# data points
pos, neg, weight = get_data(sample=2)
pos, neg = pos.T, neg.T


# ## plot training sample
plot_points(pos, neg);plt.grid()
</code></pre>

<p><img src="simple-perceptron_files/simple-perceptron_6_0.png" alt="png" /></p>

<pre><code># ## augment training vectors
aug_pos = augment(pos, aug=[1])
aug_neg = augment(neg, aug=[1])


print(aug_neg)
print(aug_pos)

[[ 1 -2 -1]
 [ 1  0 -3]]
[[ 1  0  2]
 [ 1 -1  2]
 [ 1  3 -2]]



# ## cycling trhough training samples and adjusting the weights until a solution is reached
a, iterations = fissp(aug_pos, aug_neg, weight, show_steps=1)

=&gt; initial a: [ 2  1 -2]
neg y0:[ 1. -2. -1.] * a:[ 2  1 -2] = 2.0 neg ? =&gt;  FALSE
=&gt; updated a: [ 1.  3. -1.]
pos y1:[ 1.  3. -2.] * a:[ 1.  3. -1.] = 12.0 pos ? =&gt;  CORRECT
pos y2:[ 1.  0.  2.] * a:[ 1.  3. -1.] = -1.0 pos ? =&gt;  FALSE
=&gt; updated a: [ 2.  3.  1.]
neg y3:[ 1.  0. -3.] * a:[ 2.  3.  1.] = -1.0 neg ? =&gt;  CORRECT
pos y4:[ 1. -1.  2.] * a:[ 2.  3.  1.] = 1.0 pos ? =&gt;  CORRECT
neg y0:[ 1. -2. -1.] * a:[ 2.  3.  1.] = -5.0 neg ? =&gt;  CORRECT
pos y1:[ 1.  3. -2.] * a:[ 2.  3.  1.] = 9.0 pos ? =&gt;  CORRECT
pos y2:[ 1.  0.  2.] * a:[ 2.  3.  1.] = 4.0 pos ? =&gt;  CORRECT



print(a)
# print(iterations)

[ 2.  3.  1.]



# ## get final solution, show steps, and plot solution boundary.
solution = disc_func(a)
solution.evalf(2)
</code></pre>

<script type="math/tex; mode=display">- 0.33 x_{2} - 0.67</script>

<pre><code># for the boundary length
xlim_max = max(max(pos[1,:]), max(neg[1,:]))
ylim_min = min(min(pos[:,1]), min(neg[:,1]))


# ## get decision boundary for for some range of x
x2 = sy.symbols('x2')
f = sy.lambdify(x2, solution, "numpy")
x = np.arange(ylim_min, xlim_max, 0.1)
bound = f(x)

# ## plot points
plt.figure(figsize=(8,6))
plot_points(pos, neg)

# ## plot boundary
plt.plot(bound, x, label="Final solution a = {}".format(a))
plot_all(iterations, ylim_min, xlim_max)
plt.legend(bbox_to_anchor = (2, 1))
plt.grid()
</code></pre>

<p><img src="simple-perceptron_files/simple-perceptron_13_0.png" alt="png" /></p>

<pre><code>def fissp(a_pos, a_neg, w, show_steps=0):

    # create dict of neg and pos vectors
    y_neg = {k:"neg" for k in [tuple(v) for v in a_neg]}
    y_pos = {k:"pos" for k in [tuple(v) for v in a_pos]}
    y_dict = dict(y_neg.items() + y_pos.items())

    # start fissp
    n = len(y_dict)
    k = 0
    a = w
    iterations = [a] # a record of weight updates
    all_correct = [0 for _ in range(n)]
    pattern_classfied = False

    if show_steps:  print "=&gt; initial a:", a
    while not pattern_classfied:
        sign = y_dict.values()[k]
        y = y_dict.keys()[k]
        y = np.array([float(i) for i in y])
        y_a = np.dot(y, a)

        if show_steps: print("{} y{}:{} * a:{} = {} {} ? =&gt; ".format(sign, k, y, a, y_a, sign)),

        if (sign == "neg" and y_a &lt; 1) or (sign == "pos" and y_a &gt; 0):
            if show_steps: print "CORRECT"
            all_correct[k] = 1
        else:
            if show_steps: print "FALSE"
            all_correct[k] = 0
            # update weight
            if sign == "neg":
                a = a - y
                if show_steps:  print "=&gt; updated a:", a
            if sign == "pos":
                a = a + y
                if show_steps:  print "=&gt; updated a:", a

        k = (k+1) % n
        if sum(all_correct) == n:
            return a, iterations
        else:
            iterations.append(a) # add the new a to weights aggregation



def augment(data, aug=[1]):
    """augmenting training vectors"""
    return np.array([np.append(aug, n) for n in data])
</code></pre>

<blockquote>
  <p><strong>sympy.init_printing()</strong> for latex pretty printing</p>
</blockquote>

<pre><code>import sympy as sy
sy.init_printing()

def disc_func(w):
    """ input: [a0, a1, a2]
        return the solution to: ( [a1 a2] * [x1 x2].T ) + a0
    """
    x = sy.Matrix([ 'x{}'.format(n) for n in range(1,3) ]) # create [x1 x2].T matrix of symbols

    gx = x.dot(w[1:]) + w[0] # ( [a1 a2] * [x1 x2].T ) + a0

    if len(gx.args) &gt; 2:
        return list(sy.solve(gx)[0].values())[0]
    else:
        sol = sy.solve(gx)[0]
        if isinstance(sol, dict):
            sol = sol.values()[0]
        return sol


def get_decision(x, model):
    """ input: x values (between interval), and the model
        return: result of model corresponding to x values e.g.) result = 3 * x + 2
    """
    expr = model
    # solved expr of form e.g.) x1 = .. 3x2**2 - 3x2 + 14 ..
    x2 = sy.symbols('x2')
    f = sy.lambdify(x2, expr, "numpy")
    result = f(x)
    return result
</code></pre>

<h1 id="plotting">Plotting</h1>

<pre><code>def plot_all(iterations, ylim_min, xlim_max):
    """plot all intermeiate weights solutions"""

    solutions = iterations
    if len(solutions) &gt; 6:
        solutions = solutions[:6]
    for i, a in enumerate(solutions):
        solution = disc_func(a)
        x = np.arange(ylim_min, xlim_max, 0.1)
        bound = get_decision(x, solution)
        if isinstance(bound, int):
            bound = [bound for _ in range(len(x))]
        plt.plot(x, bound, '--', label='a{}.x ={}'.format(i,a))
        plt.legend(bbox_to_anchor = (2, 1))



def plot_points(pos, neg):
    """plot positive and negative training samples"""
    plt.scatter(pos[:,0],pos[:,1], c='b', label='$Positive$')
    plt.scatter(neg[:,0],neg[:,1], c='r', label='$Negative$')


# utilities functions (data and plotting)
def get_data(sample=1):
    """
        Return training sample datapoints. by choice:
        1: class example
        2: midterm sample
        3: duda sample (ch2, ex:1)
        4: random sample
        5: Duda sample Ch.5 exercise.
    """
    if sample == 1:
        """class example"""
        pos = np.array([[1,1]]).T
        neg = np.array([[0,0],[1,0],[0,1]]).T
        w = np.array([-2,0,1])
        return pos, neg, w
    elif sample == 2:
        """midterm sample"""
        pos = np.array([[0,2],[-1,2],[3,-2]]).T
        neg = np.array([[-2,-1],[0,-3]]).T
        w = np.array([2,1,-2])
        return pos, neg, w

    elif sample == 3:
        """duda sample (ch2 ex: 1)"""
        pos = np.array([[3,8], [2,6], [4,6], [3,4]]).T
        neg = np.array([[3,0], [1,-2], [5,-2], [3,-4]]).T
        w = np.array([-2,0,1])
        return pos, neg, w
    elif sample == 4:
        """random"""
        pos = np.array([[0,0], [0,1], [2,2], [3,1], [3,2], [3,3]]).T
        neg = np.array([[6,9], [8,9], [9,8], [9,9], [9,10],[8,11]]).T
        w = np.array([-3,1,1])
        return pos, neg, w
    elif sample == 5:
        """Duda sample Ch.5"""
        w1 = np.array([[0.1, 1.1], [6.8, 7.1], [-3.5, -4.1], [2, 2.7], [4.1, 2.8], [3.1, 5], [-8, -1.3], [0.9, 1.2], [5, 6.4], [3.9, 4]]).T
        w2 = np.array([ [7.1, 4.2], [-1.4, -4.3], [4.5, 0], [6.3, 1.6], [4.2, 1.9], [1.4, -3.2], [2.4, -4], [2.5, -6.1], [8.4, 3.7], [4.1, -2.2] ]).T
        w = np.array([0,0,0])
        return w1, w2, w
    else:
        print("please enter a valid sample number or leave args blank for default sample number 1")



__author__ = "A.Aziz Altowayan"
__email__ = "aa10212w@pace.edu"
</code></pre>
]]></content>
  </entry>
  
</feed>
